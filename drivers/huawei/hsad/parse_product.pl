#!/usr/bin/perl -w

##############################################################################################
#
# Date: 2011-08-24
##############################################################################################

sub back_trim
{
    my $slash_pos = rindex($_[0], $_[1]);
    return substr($_[0], 0, $slash_pos);
}

#open ARGV[1]
$fname_no_ext = &back_trim($ARGV[0], ".");
$fname_no_ext =~ s/\\/\//;
my @path_blocks = split /\//, $fname_no_ext;
$fname_no_ext = $path_blocks[$#path_blocks];

my $product;
if ($fname_no_ext =~ /hw_(\w+)_configs/i)
{
    $product=$1;
}
else
{
    $product="INVALID_PRODUCT";
}

open FXML, "<$ARGV[0]" || die "can't open $ARGV[0]! please check your command and filesystem.";
open FOUT, ">$fname_no_ext.c" || die "can't open $ARGV[0].c";

#varible declaratio
my $key=""; #store the keys we already meet.
my %config_types;
my %config_values;

while(<FXML>)
{
    chomp;
    #module start pattern£º <module name="lcd">
    if (/^\s*<module\s+name\s*=\s*\"(\w+)\"\s*>\s*$/i)
    {
	$key = $1;
    }
    #config start pattern: <config name="truly_config">
    elsif (/^\s*<config\s+name\s*=\s*\"(\w+)\"\s*>\s*$/i)
    {
    	$key = $key."/".$1;
    }
    #module end pattern </module>
    elsif (/^\s*<\/\s*module\s*>\s*$/i)
    {
    	$key = "";
    }
    elsif (/^\s*<\/\s*config\s*>\s*$/i)
    {
    	$key = &back_trim($key,"/");
    }    
    #config start-end pattern like this: 
    #<config name="size" type="enum" value="HVGA" />
    elsif (/^\s*<config\s+name\s*=\"(\w+)\"\s+type\s*=\s*\"(\w+)\"\s+value\s*=\s*\"(\w+)\"\s*\/>\s*$/i)
    {
    	my $total_key = $key."/".$1;
    	$config_types{$total_key} = $2;
    	$config_values{$total_key} = $3;
    }
    elsif (/^\s*<config\s+name\s*=\"(\w+)\"\s+value\s*=\s*\"(\w+)\"\s+type\s*=\s*\"(\w+)\"\s*\/>\s*$/i) #fix bug.
    {
    	my $total_key = $key."/".$1;
    	$config_types{$total_key} = $3;
    	$config_values{$total_key} = $2;
    }
}
close FXML;

#print to destination c file.
select FOUT;
print "/*The file is auto generated by tools, don't modify it manully.*/\n";
print "#include <hsad/configdata.h>\n";
print "#include \"hwconfig_enum.h\"\n\n";
print "config_pair  $fname_no_ext [] = {\n";

#OK, now we're going to dump all keys-values to destination c file.
foreach $key (sort keys %config_values) {
    if ($config_types{$key} eq "string")
    {
        print "    {\"$key\", (const unsigned int)(unsigned int*)\"$config_values{$key}\", E_CONFIG_DATA_TYPE_STRING }, \n";
    }
    elsif ($config_types{$key} eq "bool")
    {
        if ($config_values{$key} eq "yes" || $config_values{$key} eq "Yes" || $config_values{$key} eq "YES")
        {
            print "    {\"$key\", (unsigned int)1, E_CONFIG_DATA_TYPE_BOOL }, \n";
        }
        elsif ($config_values{$key} eq "no" || $config_values{$key} eq "No" || $config_values{$key} eq "NO")
        {
    	print "    {\"$key\", (unsigned int)0, E_CONFIG_DATA_TYPE_BOOL }, \n";
        }
    }
    elsif ($config_types{$key} eq "enum")
    {
        print "    {\"$key\", (unsigned int)$config_values{$key}, E_CONFIG_DATA_TYPE_ENUM }, \n";
    }
    elsif ($config_types{$key} eq "int")
    {
        print "    {\"$key\", (unsigned int)$config_values{$key}, E_CONFIG_DATA_TYPE_INT }, \n";
    }
    else
    {
        #other type value, we don't support now. do nothing;		
    }
}
print "    {0, 0, 0}\n };";
print "\n";
print "struct board_id_general_struct config_common_$product= {\n";
print "	.name=COMMON_MODULE_NAME,\n";
print "	.board_id=BOARD_ID_".uc($product).",\n";
print "	.data_array={.config_pair_ptr=$fname_no_ext},\n";
print "	.list={NULL,NULL},\n";
print "};\n";

close FOUT;
